https://metanit.com/kotlin/tutorial/1.1.php

Kotlin представляет современный, статически типизированный и один из самых быстроразвивающихся языков программирования, созданный и развиваемый компанией JetBrains. Kotlin можно использовать для создания самых разных приложений. Это и приложения для мобильных устройств - Android, iOS. Причем Kotlin позволяет писать кроссплатформенный код, который будет применяться на всех платформах. Это и веб-приложения, причем как серверные приложения, которые отрабатывают на стороне на стороне сервера - бекэнда, так и браузерные клиентские приложения - фронтенд. Kotlin также можно применять для создания десктопных приложений, для Data Science и так далее.

Официальный сайт языка - https://kotlinlang.org/, где можно найти самую последнюю и самую подробную информацию по языку.


Загрузить компилятор непосредственно для самого языка Kotlin можно по адресу https://github.com/JetBrains/kotlin/releases/latest/. В самом низу страницы мы можем найти общую версию компилятора, версии компилятора Kotlin/Native для разных операционных систем, а также исходный код. Загрузим файл kotlin-compiler-1.5.0.zip:

c:\app\kotlinc\bin\kotlinc app.kt -include-runtime -d app.jar

Чтобы не писать полный путь к компилятору, путь к нему можно добавить в переменную PATH в переменных среды

C:\app\Java\jdk-11.0.11\bin\java.exe "-javaagent:C:\app\JetBrains\IntelliJ IDEA 2021.1.1\lib\idea_rt.jar=58479:C:\app\JetBrains\IntelliJ IDEA 2021.1.1\bin" -Dfile.encoding=UTF-8 -classpath C:\src\learn-kotlin-metanit\HelloKotlin\out\production\HelloKotlin;C:\Users\VKovrov\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins\Kotlin\kotlinc\lib\kotlin-stdlib.jar;C:\Users\VKovrov\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins\Kotlin\kotlinc\lib\kotlin-reflect.jar;C:\Users\VKovrov\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins\Kotlin\kotlinc\lib\kotlin-test.jar AppKt
Привет, Kotlin!


Стоит отметить, что в отличие от других похожих языков программирования, например, Java, в Kotlin не обязательно ставить после инструкции точку запятой. Каждая инструкция просто размещается на новой строке:


Для определения переменной можно использовать либо ключевое слово val, либо ключевое слово var.

Формальное определение переменной:


val|var имя_переменной: тип_переменной
Вначале идет слово val или var, затем имя переменной и через двоеточие тип переменной.

Например, определим переменную age:

val age: Int

С помощью ключевого слова val определяется неизменяемая переменная (immutable variable). То есть мы можем присвоить значение такой переменной только один раз, но изменить его после первого присвоения мы уже не сможем. Например, в следующем случае мы получим ошибку:



Целочисленные типы
Byte: хранит целое число от -128 до 127 и занимает 1 байт

Short: хранит целое число от -32 768 до 32 767 и занимает 2 байта

Int: хранит целое число от -2 147 483 648 (-231) до 2 147 483 647 (231 - 1) и занимает 4 байта

Long: хранит целое число от –9 223 372 036 854 775 808 (-263) до 9 223 372 036 854 775 807 (263-1) и занимает 8 байт

В последней версии Kotlin также добавлена поддержка для целочисленных типов без знака:

UByte: хранит целое число от 0 до 255 и занимает 1 байт

UShort: хранит целое число от 0 до 65 535 и занимает 2 байта

UInt: хранит целое число от 0 до 232 - 1 и занимает 4 байта

ULong: хранит целое число от 0 до 264-1 и занимает 8 байт






Float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта

Double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта.




\t: табуляция
\n: перевод строки
\r: возврат каретки
\': одинарная кавычка
\": двойная кавычка
\\: обратный слеш


Строки представлены типом String. Строка представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки.




Шаблоны строк
Шаблоны строк (string templates) представляют удобный способ вставки в строку различных значений, в частности, значений переменных. Так, с помощью знака доллара $ мы можем вводить в строку значения различных переменных:



Конструкция when
Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция when аналогична конструкции switch в других языках. Формальное определение:

when(объект){
     
    значение1 -> действия1
    значение2 -> действия2
     
    значениеN -> действияN
}


Функциональное программирование

fun имя_функции (параметры) : возвращаемый_тип{
    выполняемые инструкции
}

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция main. Такие функции еще называют функциями верхнего уровня (top-level functions).

Параметры указываются после имени функции в скобках через запятую в формате имя_параметра : тип_параметра. 

Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:
fun displayUser(name: String, age: Int = 18, position: String="unemployed"){

По умолчанию все параметры функции равносильны val-переменным, поэтому их значение нельзя изменить. Например, в случае следующей функции при компиляции мы получим ошибку:

Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово vararg. Например, нам необходимо передать в функцию несколько строк, но сколько именно строк, мы точно не знаем. Их может быть пять, шесть, семь и т.д.:

Оператор *
Оператор * (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива:

//STOP Возвращение результата. Оператор return


Unable to read Tip Of The Day (DBRunQueryIntention.html). Make sure IntelliJ IDEA and Database Tools and SQL plugin is installed properly.


Функция может возвращать некоторый результат. В этом случае после списка параметров через двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return, после которого указывается возвращаемое значение.
Например, определим функцию, которая возвращает сумму двух чисел:
fun sum(x:Int, y:Int): Int{

Тип Unit
Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение типа Unit. Этот тип аналогичен типу void в ряде языков программирования, которое указывает, что функция ничего не возвращает. Например, следующая функция

Однострочные функции
Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор return.
fun имя_функции (параметры_функции) = тело_функции

Локальные функции
Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными.
Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются.
Например, у нас есть функция, которая сравнивает два возраста:


В Kotlin все является объектом, в том числе и функции. И функции, как и другие объекты, имеют определенный тип. Тип функции определяется следующим образом:
(типы_параметров) -> возвращаемый_тип

Функции высокого порядка (high order function) - это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое.
Функция как параметр функции
Чтобы функция могла принимать другую функцию через параметр, этот параметр должен представлять тип функции:

Возвращение функции из функции
В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение. Например:

Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени. Анонимная функция может иметь одно выражение:
fun(x: Int, y: Int): Int = x + y
Либо может представлять блок кода:
fun(x: Int, y: Int): Int{ 
    return x + y
}


trailing lambda
Если параметр, который принимает функцию, является последним в списке, то при передачи ему лямбда-выражения, саму лямбду можно прописать после списка параметров. Например, возьмем выше использованную функцию doOperation():




Объектно-ориентированное программирование
Классы и объекты

Для создания объекта необходимо вызвать конструктор класса. По умолчанию компилятор создает конструктор, который не принимает параметров и который мы можем использовать. Но также мы можем определять свои собственные конструкторы. Для определения конструкторов применяется ключевое слово constructor.

Классы в Kotlin могут иметь один первичный конструктор (primary constructor) и один или несколько вторичных конструкторов (secondary constructor).

Первичный конструктор
Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:

Инициализатор
Что делать с полученными через конструктор данными? Мы их можем использовать для инициализации свойств класса. Для этого применяются блоки инициализаторов:

Вторичные конструкторы
Класс также может определять вторичные конструкторы. Они применяются в основном, чтобы определить дополнительные параметры, через которые можно передавать данные для инициализации объекта.
Вторичные конструкторы определяются в теле класса. Если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова this:

// STOP Пакеты и импорт

Псевдонимы
С помощью оператора as можно определять псевдоним для подключаемого типа и затем обращаться к этому типу через его псевдоним:

Встроенные пакеты
Kotlin имеет ряд встроенных пакетов, которые подключаюся по умолчанию в любой файл на языке Kotlin:
kotlin.*
kotlin.annotation.*
kotlin.collections.*
kotlin.comparisons.*
kotlin.io.*
kotlin.ranges.*
kotlin.sequences.*
kotlin.text.*


Наследование
Наследование позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего это базовый класс (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И производный класс (класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее.
Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию open. По умолчанию без этой аннотации класс не может быть унаследован.

open class базовый_класс
class производный_класс: базовый_класс


Стоит отметить, что в Kotlin мы можем унаследовать класс только от одного класса, множественное наследование не поддерживается.
Также, стоит отметить, что все классы по умолчанию наследуются от класса Any, даже если класс Any явным образом не указан в качестве базового. Поэтому любой класс уже по умолчанию будет иметь все свойства и функции, которые определены в классе Any. Поэтому все классы по умолчанию уже будут иметь такие функции как equals, toString, hashcode.

Модификаторы видимости


Геттеры и сеттеры
Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной. Их формальный синтаксис:

// STOP Переопределение методов и свойств

Kotlin позволяет переопределять в производном классе функции и свойства, которые определенны в базовом классе. Чтобы функции и свойства базового класа можно было переопределить, к ним применяется аннотация open. При переопределении в производном классе к этим функциям применяется аннотация override.

Запрет переопределения
В это же время иногда бывает необходимо запретить дальнейшее переопределение функции в классах-наследниках. Для этого применяется ключевое слово final:

Обращение к реализации из базового класса
С помощью ключевого слова super в производном классе можно обращаться к реализации из базового класса.

Абстрактные классы и методы
Абстрактные классы - это классы, определенные с модификатором abstract. Отличительной особенностью абстрактных классов является то, что мы не можем создать объект подобного класса. Например, определим абстрактный класс Human:

Стоит отметить, что в данном случае перед абстрактным классом не надо указывать аннотацию open, как при наследовании неабстрактных классов.



Интерфейсы
При определении свойств в интерфейсе име не присваиваются значения.

Мы не можем напрямую создать объект интерфейса, так как интерфейс не поддерживает конструкторы и просто представляет шаблон, которому класс должен соответствовать.

Правила переопределения
В Kotlin мы можем наследовать класс и применять интерфейсы. При этом мы можем одновременно и наследоваться от класса, и применять один или несколько интерфейсов. Однако что, если переопределяемая функция из базового класса имеет то же имя, что и функция из применяемого интерфейса:

Вложенные классы и интерфейсы
В Kotlin классы и интерфейсы могут быть определены в других классах и интерфейсах. Такие классы (вложенные классы или nested classes) обычно выполняют какую-то вспомогательную роль, а определение их внутри класса или интерфейса позволяет разместить их как можно ближе к тому месту, где они непосредственно используются.

Внутренние (inner) классы
Стоит учитывать, что вложенный (nested) класс по умолчанию не имеет доступа к свойствам и функциям внешнего класса. Например, в следующем случае при попытке обратиться к свойству внешнего класса мы получим ошибку:

Чтобы вложенный класс мог иметь доступ к свойствам и функциям внешнего класса, необходимо определить вложенный класс с ключевым словом inner. Такой класс еще называют внутренним классом (inner class), чтобы отличать от обычных вложенных классов. Например:


Совпадение имен
Но что если свойства и функции внутреннего класса называются также, как и свойства и функции внешнего класса? В этом случае внутренний класс может обратиться к свойствам и функциям внешнего через конструкцию this@название_класса.имя_свойства_или_функции:

// STOP Data-классы

Data-классы
Иногда классы бывают необходимы только для хранения некоторых данных. В Kotlin такие классы называются data-классы. Они определяются с модификатором data:

При компиляции такого класса компилятор автоматически добавляет в класс функции с определенной реализацией, которая учитывает свойства класса, которые определены в первичном конструкторе:
equals(): сравнивает два объекта на равенство
hashCode(): возвращает хеш-код объекта
toString(): возвращает строковое представление объекта
copy(): копирует данные объекта в другой объект

Первичный конструктор должен иметь как минимум один параметр
Все параметры первичного конструктора должны предваряться ключевыми словами val или var, то есть определять свойства
Свойства, которые определяются вне первичного конструктора, не используются в функциях toString, equals и hashCode
Класс не должен определяться с модификаторами open, abstract, sealed или inner.

Декомпозиция data-классов
Kotlin предоставляет для data-классов возможность декомпозиции на переменные:

Перечисления enums
Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. Для определения перечисления применяются ключевые слова enum class. Например, определим перечисление:

При этом перечисления - это не просто список значений. Они могут определять также свойства и функции. Но если класс перечисления содержит свойства или функции, то константы должны быть отделены точкой с запятой.

Все перечисления обладают двумя встроенными свойствами:
name: возвращает название константы в виде строки
ordinal: возвращает порядковый номер константы

Кроме того, в Kotlin нам доступны вспомогательные функции:
valueOf(value: String): возвращает объект перечисления по названию константы
values(): возвращает массив констант текущего перечисления

Делегирование

Делегирование представляет паттерн объектно-ориентированного программирования, который позволяет одному объекту делегировать/перенаправить все запросы другому объекту. В определенной степени делегирование может выступать альтернативой наследованию. И преимуществом Kotlin в данном случае состоит в том, что Kotlin нативно поддерживает данный паттерн, предоставляя необходимый инструментарий.

Множественное делегирование
Подобным образом один объект может делегировать выполнение различных функций разным объектам. Например:

Делегирование свойств
По аналогии с функциями объект может делегировать обращение к свойствам:


Анонимные классы и объекты
Иногда возникает необходимость создать объект некоторого класса, который больше нигде в программе не используется. То есть класс необходим только для создания только одного объекта. В этом случае мы, конечно, можем, как и обычно, определить класс и затем создать объект этого класса. Но Kotlin для таких ситуаций предоставлять возможность определить объект анонимного класса.

Анонимные классы не используют ключевое слово class для определения. Они не имеют имени, но как и обычные классы могут наслдовать другие классы или применять интерфейсы. Объекты анонимных классов называют анонимыми объктами.

Наследование анонимных объектом
При наследовании после слова object через двоеточия указывается имя наследуемого класса или его первичный конструктор:

Анонимный объект как аргумент функции
Анонимный объект может передаваться в качестве аргумента в вызов функции:

Анонимный объект как результат функции
Функция может возвращать анонимный объект:


// STOP  Обобщения
Обобщенные классы и функции


Обобщения
Обобщенные классы и функции
Generics или обобщения представляют технику, посредством которой методы и классы могут использовать объекты, типы которых на момент определения классов и функций неизвестны. Обобщения позволяют определять шаблоны, в которые можно подставлять различные типы.
class Person<T>(val id: T, val name: String)

Ограничения обобщений
Ограничения обобщений (generic constraints) ограничивают набор типов, которые могут передаваться вместо параметра в обобщениях.

Стоит отметить, что по умолчанию ко всем параметрам типа также применяется ограничение в виде типа Any?. То есть определение параметра типа <T> фактически аналогично определению <T: Any?>

Классы, как и функции, могут принимать ограничения обощений.


Вариантность, ковариантность и контравариантность
Вариантность описывает, как обобщенные типы, типизированные классами из одной иерархии наследования, соотносятся друг с другом.

Ковариантость
Ковариантость предполагает, что, если у нас есть классы Base и Derived, где Base - базовый класс для Derived, то класс SomeClass<Base> является базовым классом для SomeClass<Derived>
Для определения обобщенного типа как ковариантного параметр обощения определяется с ключевым словом out:
-
Поскольку в Messenger параметр T определен с аннотацией out, то мы можем присвоить переменной типа Messenger<Message> значение типа EmailMessenger (а по сути значение типа Messenger<EmailMessage>)
-
В то же время тип T нельзя использовать в качестве типа входных параметров функции. Например, в следующем случае компилятор известит нас об ошибке:

Контравариантность
Применение аннотации in означает, что обобщенный тип может получать значение типа T через параметр функции:
-
В данном случае интерфейс Messenger является контравариантным, так как его параметр определен со словом in: interface Messenger<in T>. И теперь переменной типа Messenger<EmailMessage> мы можем присвоить значение типа Messenger<Message>
-
Применение аннотации in означает, что обобщенный тип может получать значение типа T через параметр функции:


Дополнительные возможности ООП
Обработка исключений

Оператор throw
Возможно, в каких-то ситуациях мы вручную захотим генерировать исключение. Для генерации исключения применяется оператор throw, после которого указывается объект исключения

Возвращение значения
Конструкция try может возвращать значение. Например:



Null и nullable-типы
Ключевое слово null представляет специальный литерал, который указывает, что переменная не имеет как такового значения. То есть у нее по сути отсутствует значение.

Мы можем присвоить значение null только переменной, которая представляет тип Nullable. Чтобы превратить обычный тип в тип nullable, достаточно поставить после названия типа вопросительный знак:

В то же время надо понимать, что String? и Int? - это не то же самое, что и String и Int. Nullable типы имеют ряд ограничений:
Значения nullable-типов нельзя присвоить напрямую переменным, которые не допускают значения null
-
У объектов nullable-типов нельзя вызвать напрямую те же функции и свойства, которые есть у обычных типов

Оператор ?:
оператор ?:, который позволяет предоставить альтернативное значение, если присваиваемое значение равно null:

Оператор ?.
Оператор ?. позволяет объединить проверку значения объекта на null и обратиться к функциям или свойствам этого объекта.

Оператор !!
Оператор !! (not-null assertion operator) принимает один операнд. Если операнд равен null, то генерируется исключение. Если операнд не равен null, то возвращается его значение.



// STOP Делегированные свойства
Делегированные свойства позволяют делегировать получение или присвоение их значения во вне - другому классу. Это позволяет нам добавить некоторую дополнительную логику при операции со свойствами, например, логгирование, какую-то предобработку и т.д.
Формальный синтаксис делегированного свойства:
val/var имя_свойства: тип_данных by выражение
После типа данных свойства идет ключевое слово by, после которого указывается выражение. Выражение представляет класс, который условно называется делегатом. Делегаты свойств могут не применять никаких интерфейсов, однако они должны предоставлять функции getValue() и setValue(). А выполнение методов доступа get() и set(), которые есть у свойства, делегируется функциям getValue() и setValue() класса делегата.

Изменяемые свойства
Для изменяемых свойств (var-свойств) делегат должен также предоставить функцию setValue(), которая принимает следующие параметры:
thisRef: должен представлять тот же тип, что и свойство, к которому применяется делегат. Это может быть и родительский тип.
property: должен представлять тот же тип KProperty<*> или его родительский тип
value: должен представлять тот же тип, что и свойство, или его родительский тип


Преобразование типов
Встроенные методы преобразования типов
Для преобразования данных одного типа в другой можно использовать встроенные следующие функции, которые есть у базовых типов (Int, Long, Double и т.д.) (Конкретный набор функций для разных базовых типов может отличаться. ):
toByte
toShort
toInt
toLong
toFloat
toDouble
toChar


Smart cast и оператор is
Оператор is позволяет проверить выражение на принадлежность определенному типу данных:
значение is тип_данных

fun checkEmployment(person: Person){
    // println("${person.name} works in ${person.company}")    // Ошибка - у Person нет свойства company

    // Причем даже если значение представляет тип Employee, то до применения оператора is оно тем не менее принадлежит
    // типу Person. И только применение оператора is преобразует значение из типа Person в тип Employee.
    if(person is Employee){
        println("${person.name} works in ${person.company}")
    }

Ограничения умных преобразований
Подобные smart-преобразования тем не менее имеют ограничения. Они могут применяться, только если компилятор может гарантировать, что переменная не изменила своего значения в промежутке между проверкой и использованием. Для smart-преобразований действуют следующие правила:
-- smart-преобразования применяются к локальным val-переменным (за исключением делегированных свойств)
-- smart-преобразования применяются к val-свойствам, за исключением свойств с модификатором open (то есть открытых к переопределению в производных классах) или свойств, для которых явным образом определен геттер
-- smart-преобразования применяются к локальным var-переменным, если переменная не изменяет своего значения в промежутке между проверкой и использованием и не используется в лямбда-выражении, которое изменяет ее, а также не является локальным делегированным свойством
-  к var-свойствам smart-преобразования не применяются

Явные преобразования и оператор as
С помощью оператора as мы можем приводить значения одного типа к другому типу:
значение as тип_данных


Функции расширения
Функции расширения (extension function) позволяют добавить функционал к уже определенным типам. При этом типы могут быть определены где-то в другом месте, например, в стандартной библиотеке.

Функция расширения определяется следующим образом:
fun тип.имя_функции(параметры) : возвращаемый_тип{
    тело функции
}

Следует учитывать, что в функциях расширения мы можем обращаться к любым общедоступным свойствам и методам объекта, однако не можем обращаться к свойствам и методам с модификаторами private и protected.


Инфиксная нотация
Инфиксная нотация представляет помещение оператора или функции перед операндами или аргументами. Для определения инфиксной функции вначале ее определения указывается ключевое слово infix:

infix fun название_функции(параметр: тип_параметра): тип_возвращаемого_значения{
    // действия функции
}

Инфиксная функция должна принимать только один параметр. При этом параметр не должен иметь значение по умолчанию и не должен представлять неопределенный набор значений.

Есть два способа определения инфиксной функции: либо внутри класса, либо как функции расширения.


// STOP     Коллекции
Коллекции
Изменяемые и неизменяемые коллекции

Kotlin не имеет собственной библиотеки коллекций и полностью полагается на классы коллекций, которые предоставляет Java. В то же время эти коллекции в Kotlin расширяются дополнительными возможностями.

Так, в Kotlin коллекции разделяются на изменяемые (mutable) и неизменяемые (immutable) коллекции.

Mutable-коллекция может изменяться, в нее можно добавлять, в ней можно изменять, удалять элементы. Immutable-коллекция также поддерживает добавление, замену и удаление данных, однако в процессе подобных операций коллекция будет заново пересоздаваться.

Все коллекции в Kotlin располагаются в пакете kotlin.collections. Полный список интерфейсов и классов, которые представляют коллекции, можно найти здесь.

Основным интерфейсом, который позволяет работать с коллекциями, является kotlin.Collection. Данный интерфейс определяет функциональность для перебора элементов, проверки наличия элементов, чтения данных. Однако он не предоставляет возможности по добавлению и удалению данных. Его основные компоненты:
size: возвращает количество элементов в коллекции
isEmpty(): возвращает true, если коллекция пустая
contains(element): возвращает true, если коллекция содержит element
containsAll(collection): возвращает true, если коллекция содержит элементы коллекции collection

Для создания объекта List применяется метод listOf():

Изменяемые списки представлены интерфейсом MutableList. Он расширяет интерфейс List и позволяют добавлять и удалять элементы. Данный интерфейс реализуется классом ArrayList.

Для создания изменяемых списков можно использовать ряд методов:

arrayListOf(): создает объект ArrayList
mutableListOf(): создает объект MutableList


Интерфейс MutableSet реализуется следующими типами изменяемых наборов:
LinkedHashSet: объединяет возможности хеш-таблицы и связанного списка. Создается с помощью функции linkedSetOf().
HashSet: представляет хеш-таблицу. Создается с помощью функции hashSetOf().

Коллекция Map представляет коллекцию объектов, где каждый элемент имеет ключ и сопоставляемое с ним значение. При этом все ключи в коллекции являются уникальными. В отличие от List и Set интерфейс Map не расширяет интерфейс Collection.

Map представляет неизменяемую коллекцию, для создания которой применяется метод mapOf().
HashMap: простейшая реализация интерфейса MutableMap, не гарантирует порядок элементов в коллекции. Создается функцией hashMapOf()
LinkedHashMap: представляет комбинацию HashMap и связанного списка, создается функцией linkedMapOf()



Корутины
Введение в корутины
kotlinx.coroutines
В языке Kotlin поддержка асинхронности и параллельных вычислений воплощена в виде корутин (coroutine). По сути корутина представляет блок кода, который может выполняться параллельно с остальным кодом. А базовая функциональность, связанная с корутинами, сосредоточена в библиотеке kotlinx.coroutines.

Добавление kotlinx.coroutines
Прежде всего стоит отметить, что функциональность корутин (библиотека kotlinx.coroutines) по умолчанию не включена в проект. И нам ее надо добавить. Если мы создаем проект консольного приложения в IntelliJ IDEA, то мы можем добавить соответствующую библиотеку в проект. Для этого в меню File перейдем к пункту Project Structure
....Libraries....
Нас перебросит к папке lib, которая содержит устанавливаемые по умолчанию библиотеки Kotlin. Выберем среди них библиотеку kotlinx-coroutines-core.jar и нажмем на OK для ее добавления:

В других типах проектов для подключения kotlinx.coroutines может использоваться Gradle или другие способы.


Определение suspend-функции
корутина может вызываться только в контексте корутины (coroutine scope). Для этого применяется функция coroutineScope() - создает контекст корутины.
Сама корутина определяется и запускается с помощью построителя корутин - функции launch. Она создает корутину в виде блока кода - в данном случае это:

Корутины и потоки
В ряде языков программирования есть такие структуры, которые позволяют использовать потоки. Однако между корутинами и потоками нет прямого соответствия. Корутина не привязана к конкретному потоку. Она может быть приостановить выполнение в одном потоке, а возобновить выполнение в другом.

launch и Job
Прежде всего, launch(), как правило, применяется, когда нам не надо возвращать результат из корутины и когда нам ее надо выполнять одновременно с другим кодом.

Job
Построитель корутин launch возвращает объект Job, с помощью которого можно управлять запущеной корутиной:
его метод join() позволяет ожидать, пока корутина не завершится. Например:

Отложенное выполнение
По умолчанию построитель корутин launch создает и сразу же запускает корутину. Однако Kotlin также позволяет применять технику отложенного запуска корутины (lazy-запуск), при котором корутина запускается при вызове метода start() объекта Job.
Для установки отложенного запуска в функцию launch() передается значение start = CoroutineStart.LAZY


Async, await и Deferred
Наряду с launch в пакете kotlinx.coroutines есть еще один построитель корутин - функция async. Эта функция применяется, когда надо получить из корутины некоторый результат.

async запускает отдельную корутину, которая выполняется параллельно с остальными корутинами. Кроме того, она возвращает объект Deferred, который ожидает получения результата корутины. (Интерфейс Deferred унаследован от интерфейса Job, поэтому для также доступны весь функционал, определенный для интефейса Job)

Для получения результата из объекта Deferred применяется функция await(). Рассмотрим на примере:

Отложенный запуск
По умолчанию построитель корутин async создает и сразу же запускает корутину. Но как и при создании корутины с помощью launch для async-корутин можно применять технику отложенного запуска. Только в данном случае корутина запускается не только при вызове метода start объекта Deferred (который усналедован от интерфейса Job), но также и с помощью метода await() при обращении к результу корутины. Например:


// STOP Диспетчер корутины
Контекст корутины включает себя такой элемент как диспетчер корутины. Диспетчер корутины определяет какой поток или какие потоки будут использоваться для выполнения корутины.


доступные типы диспетчеров:

Dispatchers.Default: применяется по умолчанию, если тип диспетчера не указан явным образом. Этот тип использует общий пул разделяемых фоновых потоков и подходит для вычислений, которые не работают с операциями ввода-вывода (операциями с файлами, базами данных, сетью) и которые требуют интенсивного потребления ресурсов центрального процессора.

Dispatchers.IO: использует общий пул потоков, создаваемых по мере необходимости, и предназначен для выполнения операций ввода-вывода (например, операции с файлами или сетевыми запросами).

Dispatchers.Main: применяется в графических приложениях, например, в приложениях Android или JavaFX.

Dispatchers.Unconfined: корутина не закреплена четко за определенным потоком или пулом потоков. Она запускается в текущем потоке до первой приостановки. После возобновления работы корутина продолжает работу в одном из потоков, который сторого не фиксирован. Разработчики языка Kotlin в обычной ситуации не рекомендуют использовать данный тип.

newSingleThreadContext и newFixedThreadPoolContext: позволяют вручную задать поток/пул для выполнения корутины

-------------
Dispatchers.Unconfined
Тип Dispatchers.Unconfined запускает корутину в текущем вызывающем потоке до первой приостановки. После возобновления корутина продолжает работу в одном из потоков, который строго не фиксирован. Подобный тип подходит для корутин, которым не требуется интенсивно потреблять время CPU или работать с общими данными, наподобие объектов пользовательского интерфейса.

В то же время выделенный поток является довольно затратным ресурсом. И в реальном приложении подобый поток следует либо освобождать с помощью функции close(), если он больше не нужен, либо хранить в глобальной переменной и использовать его повторно для подобных задач на протяжении работы приложения.


Отмена выполнения корутин
При работе приложения может сложиться необходимость отменить выполнение корутины. Например, в мобильном приложении запущена корутина для загрузки данных с некоторого интернет-ресуса, но пользователь решил перейти к другой странице приложения, и ему больше не нужны эти данные. В этом случае чтобы зря не тратить ресурсу системы, мы можем предусмотреть отмену выполнения корутины.
--
Для отмены выполнения корутины у объекта Job может применяться метод cancel():

Также вместо двух методов cancel() и join() можно использовать один сборный метод cancelAndJoin():

Обработка исключения CancellationException
Все suspend-функции в пакете kotlinx.coroutines являются прерываемыми (cancellable). Это значит, что они проверяют, прервана ли корутина. И если ее выполнение прервано, они генерируют исключение типа CancellationException. И в самой корутине мы можем перехватить это исключение, чтобы обработать отмену корутины


Каналы
Каналы позволяют передавать потоки данных. В Kotlin каналы представлены интерфейсом Channel, у которого следует выделить два основных метода:
abstract suspend fun send(element: E): Unit
Отправляет объект element в канал
abstract suspend fun receive(): E
Получает данные из канала
Определим простейший канал, через который будем передавать числа типа Int:

Закрытие канала
Чтобы указать, что в канале больше нет данных, его можно закрыть с помощью метода close(). Если для получения данных из канала применяется цикл for, то, получив сигнал о закрытии канала, данный цикл получит все ранее посланные объекты до закрытия и завершит выполнение:


Паттерн producer-consumer
Рассмотренный выше пример по сути является распростаненным способом передачи данных от одной корутины к другой. И чтобы упростить написание подобного кода, Kotlin предоставляет ряд дополнительных функций. Так, функция produce() представляет построитель корутины, который создает корутину, в которой передаются данные в канал. Например, с помощью функции produce() мы можем определить новую функцию-корутину, которая будет отправлять определенные данные:


Асинхронные потоки
Введение в асинхронные потоки
Корутины позволяют возвращать одиночные значения. Для этого мы можем, к примеру, создавать корутину с помощью построителя async. Но Kotlin также позволяет создавать асинхронные потоки (Asynchronous Flow), которые возвращают набор объектов.


Для создания асинхронного потока данных применяется интерфейс Flow. То есть по сути асинхронный поток - это объект Flow. Он типизируется типом тех данных, которые должны передаваться в потоке. В данном случае передаем строки, поэтому Flow типизируется типом String.



Запуск Flow
Стоит отметить, что асинхронный поток не запускается, пока не будет применена терминальная операция над получаемыми даными, например, функция collect():






