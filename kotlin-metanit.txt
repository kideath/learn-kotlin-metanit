https://metanit.com/kotlin/tutorial/1.1.php

Kotlin представляет современный, статически типизированный и один из самых быстроразвивающихся языков программирования, созданный и развиваемый компанией JetBrains. Kotlin можно использовать для создания самых разных приложений. Это и приложения для мобильных устройств - Android, iOS. Причем Kotlin позволяет писать кроссплатформенный код, который будет применяться на всех платформах. Это и веб-приложения, причем как серверные приложения, которые отрабатывают на стороне на стороне сервера - бекэнда, так и браузерные клиентские приложения - фронтенд. Kotlin также можно применять для создания десктопных приложений, для Data Science и так далее.

Официальный сайт языка - https://kotlinlang.org/, где можно найти самую последнюю и самую подробную информацию по языку.


Загрузить компилятор непосредственно для самого языка Kotlin можно по адресу https://github.com/JetBrains/kotlin/releases/latest/. В самом низу страницы мы можем найти общую версию компилятора, версии компилятора Kotlin/Native для разных операционных систем, а также исходный код. Загрузим файл kotlin-compiler-1.5.0.zip:

c:\app\kotlinc\bin\kotlinc app.kt -include-runtime -d app.jar

Чтобы не писать полный путь к компилятору, путь к нему можно добавить в переменную PATH в переменных среды

C:\app\Java\jdk-11.0.11\bin\java.exe "-javaagent:C:\app\JetBrains\IntelliJ IDEA 2021.1.1\lib\idea_rt.jar=58479:C:\app\JetBrains\IntelliJ IDEA 2021.1.1\bin" -Dfile.encoding=UTF-8 -classpath C:\src\learn-kotlin-metanit\HelloKotlin\out\production\HelloKotlin;C:\Users\VKovrov\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins\Kotlin\kotlinc\lib\kotlin-stdlib.jar;C:\Users\VKovrov\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins\Kotlin\kotlinc\lib\kotlin-reflect.jar;C:\Users\VKovrov\AppData\Roaming\JetBrains\IntelliJIdea2021.2\plugins\Kotlin\kotlinc\lib\kotlin-test.jar AppKt
Привет, Kotlin!


Стоит отметить, что в отличие от других похожих языков программирования, например, Java, в Kotlin не обязательно ставить после инструкции точку запятой. Каждая инструкция просто размещается на новой строке:


Для определения переменной можно использовать либо ключевое слово val, либо ключевое слово var.

Формальное определение переменной:


val|var имя_переменной: тип_переменной
Вначале идет слово val или var, затем имя переменной и через двоеточие тип переменной.

Например, определим переменную age:

val age: Int

С помощью ключевого слова val определяется неизменяемая переменная (immutable variable). То есть мы можем присвоить значение такой переменной только один раз, но изменить его после первого присвоения мы уже не сможем. Например, в следующем случае мы получим ошибку:



Целочисленные типы
Byte: хранит целое число от -128 до 127 и занимает 1 байт

Short: хранит целое число от -32 768 до 32 767 и занимает 2 байта

Int: хранит целое число от -2 147 483 648 (-231) до 2 147 483 647 (231 - 1) и занимает 4 байта

Long: хранит целое число от –9 223 372 036 854 775 808 (-263) до 9 223 372 036 854 775 807 (263-1) и занимает 8 байт

В последней версии Kotlin также добавлена поддержка для целочисленных типов без знака:

UByte: хранит целое число от 0 до 255 и занимает 1 байт

UShort: хранит целое число от 0 до 65 535 и занимает 2 байта

UInt: хранит целое число от 0 до 232 - 1 и занимает 4 байта

ULong: хранит целое число от 0 до 264-1 и занимает 8 байт






Float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта

Double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта.




\t: табуляция
\n: перевод строки
\r: возврат каретки
\': одинарная кавычка
\": двойная кавычка
\\: обратный слеш


Строки представлены типом String. Строка представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки.




Шаблоны строк
Шаблоны строк (string templates) представляют удобный способ вставки в строку различных значений, в частности, значений переменных. Так, с помощью знака доллара $ мы можем вводить в строку значения различных переменных:



Конструкция when
Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция when аналогична конструкции switch в других языках. Формальное определение:

when(объект){
     
    значение1 -> действия1
    значение2 -> действия2
     
    значениеN -> действияN
}


Функциональное программирование

fun имя_функции (параметры) : возвращаемый_тип{
    выполняемые инструкции
}

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция main. Такие функции еще называют функциями верхнего уровня (top-level functions).

Параметры указываются после имени функции в скобках через запятую в формате имя_параметра : тип_параметра. 

Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:
fun displayUser(name: String, age: Int = 18, position: String="unemployed"){

По умолчанию все параметры функции равносильны val-переменным, поэтому их значение нельзя изменить. Например, в случае следующей функции при компиляции мы получим ошибку:

Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово vararg. Например, нам необходимо передать в функцию несколько строк, но сколько именно строк, мы точно не знаем. Их может быть пять, шесть, семь и т.д.:

Оператор *
Оператор * (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива:

//STOP Возвращение результата. Оператор return


Unable to read Tip Of The Day (DBRunQueryIntention.html). Make sure IntelliJ IDEA and Database Tools and SQL plugin is installed properly.


Функция может возвращать некоторый результат. В этом случае после списка параметров через двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return, после которого указывается возвращаемое значение.
Например, определим функцию, которая возвращает сумму двух чисел:
fun sum(x:Int, y:Int): Int{

Тип Unit
Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение типа Unit. Этот тип аналогичен типу void в ряде языков программирования, которое указывает, что функция ничего не возвращает. Например, следующая функция

Однострочные функции
Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор return.
fun имя_функции (параметры_функции) = тело_функции

Локальные функции
Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными.
Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются.
Например, у нас есть функция, которая сравнивает два возраста:


В Kotlin все является объектом, в том числе и функции. И функции, как и другие объекты, имеют определенный тип. Тип функции определяется следующим образом:
(типы_параметров) -> возвращаемый_тип

Функции высокого порядка (high order function) - это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое.
Функция как параметр функции
Чтобы функция могла принимать другую функцию через параметр, этот параметр должен представлять тип функции:

Возвращение функции из функции
В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение. Например:

Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени. Анонимная функция может иметь одно выражение:
fun(x: Int, y: Int): Int = x + y
Либо может представлять блок кода:
fun(x: Int, y: Int): Int{ 
    return x + y
}


trailing lambda
Если параметр, который принимает функцию, является последним в списке, то при передачи ему лямбда-выражения, саму лямбду можно прописать после списка параметров. Например, возьмем выше использованную функцию doOperation():




Объектно-ориентированное программирование
Классы и объекты

Для создания объекта необходимо вызвать конструктор класса. По умолчанию компилятор создает конструктор, который не принимает параметров и который мы можем использовать. Но также мы можем определять свои собственные конструкторы. Для определения конструкторов применяется ключевое слово constructor.

Классы в Kotlin могут иметь один первичный конструктор (primary constructor) и один или несколько вторичных конструкторов (secondary constructor).

Первичный конструктор
Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:

Инициализатор
Что делать с полученными через конструктор данными? Мы их можем использовать для инициализации свойств класса. Для этого применяются блоки инициализаторов:

Вторичные конструкторы
Класс также может определять вторичные конструкторы. Они применяются в основном, чтобы определить дополнительные параметры, через которые можно передавать данные для инициализации объекта.
Вторичные конструкторы определяются в теле класса. Если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова this:

// STOP Пакеты и импорт

Псевдонимы
С помощью оператора as можно определять псевдоним для подключаемого типа и затем обращаться к этому типу через его псевдоним:

Встроенные пакеты
Kotlin имеет ряд встроенных пакетов, которые подключаюся по умолчанию в любой файл на языке Kotlin:
kotlin.*
kotlin.annotation.*
kotlin.collections.*
kotlin.comparisons.*
kotlin.io.*
kotlin.ranges.*
kotlin.sequences.*
kotlin.text.*


Наследование
Наследование позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего это базовый класс (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И производный класс (класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее.
Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию open. По умолчанию без этой аннотации класс не может быть унаследован.

open class базовый_класс
class производный_класс: базовый_класс


Стоит отметить, что в Kotlin мы можем унаследовать класс только от одного класса, множественное наследование не поддерживается.
Также, стоит отметить, что все классы по умолчанию наследуются от класса Any, даже если класс Any явным образом не указан в качестве базового. Поэтому любой класс уже по умолчанию будет иметь все свойства и функции, которые определены в классе Any. Поэтому все классы по умолчанию уже будут иметь такие функции как equals, toString, hashcode.

Модификаторы видимости


Геттеры и сеттеры
Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной. Их формальный синтаксис:

// STOP Переопределение методов и свойств

Kotlin позволяет переопределять в производном классе функции и свойства, которые определенны в базовом классе. Чтобы функции и свойства базового класа можно было переопределить, к ним применяется аннотация open. При переопределении в производном классе к этим функциям применяется аннотация override.

Запрет переопределения
В это же время иногда бывает необходимо запретить дальнейшее переопределение функции в классах-наследниках. Для этого применяется ключевое слово final:

Обращение к реализации из базового класса
С помощью ключевого слова super в производном классе можно обращаться к реализации из базового класса.

Абстрактные классы и методы
Абстрактные классы - это классы, определенные с модификатором abstract. Отличительной особенностью абстрактных классов является то, что мы не можем создать объект подобного класса. Например, определим абстрактный класс Human:

Стоит отметить, что в данном случае перед абстрактным классом не надо указывать аннотацию open, как при наследовании неабстрактных классов.



Интерфейсы
При определении свойств в интерфейсе име не присваиваются значения.

Мы не можем напрямую создать объект интерфейса, так как интерфейс не поддерживает конструкторы и просто представляет шаблон, которому класс должен соответствовать.

Правила переопределения
В Kotlin мы можем наследовать класс и применять интерфейсы. При этом мы можем одновременно и наследоваться от класса, и применять один или несколько интерфейсов. Однако что, если переопределяемая функция из базового класса имеет то же имя, что и функция из применяемого интерфейса:

Вложенные классы и интерфейсы
В Kotlin классы и интерфейсы могут быть определены в других классах и интерфейсах. Такие классы (вложенные классы или nested classes) обычно выполняют какую-то вспомогательную роль, а определение их внутри класса или интерфейса позволяет разместить их как можно ближе к тому месту, где они непосредственно используются.

Внутренние (inner) классы
Стоит учитывать, что вложенный (nested) класс по умолчанию не имеет доступа к свойствам и функциям внешнего класса. Например, в следующем случае при попытке обратиться к свойству внешнего класса мы получим ошибку:

Чтобы вложенный класс мог иметь доступ к свойствам и функциям внешнего класса, необходимо определить вложенный класс с ключевым словом inner. Такой класс еще называют внутренним классом (inner class), чтобы отличать от обычных вложенных классов. Например:


Совпадение имен
Но что если свойства и функции внутреннего класса называются также, как и свойства и функции внешнего класса? В этом случае внутренний класс может обратиться к свойствам и функциям внешнего через конструкцию this@название_класса.имя_свойства_или_функции:

// STOP Data-классы

Data-классы
Иногда классы бывают необходимы только для хранения некоторых данных. В Kotlin такие классы называются data-классы. Они определяются с модификатором data:

При компиляции такого класса компилятор автоматически добавляет в класс функции с определенной реализацией, которая учитывает свойства класса, которые определены в первичном конструкторе:
equals(): сравнивает два объекта на равенство
hashCode(): возвращает хеш-код объекта
toString(): возвращает строковое представление объекта
copy(): копирует данные объекта в другой объект

Первичный конструктор должен иметь как минимум один параметр
Все параметры первичного конструктора должны предваряться ключевыми словами val или var, то есть определять свойства
Свойства, которые определяются вне первичного конструктора, не используются в функциях toString, equals и hashCode
Класс не должен определяться с модификаторами open, abstract, sealed или inner.

Декомпозиция data-классов
Kotlin предоставляет для data-классов возможность декомпозиции на переменные:

Перечисления enums
Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. Для определения перечисления применяются ключевые слова enum class. Например, определим перечисление:

При этом перечисления - это не просто список значений. Они могут определять также свойства и функции. Но если класс перечисления содержит свойства или функции, то константы должны быть отделены точкой с запятой.

Все перечисления обладают двумя встроенными свойствами:
name: возвращает название константы в виде строки
ordinal: возвращает порядковый номер константы

Кроме того, в Kotlin нам доступны вспомогательные функции:
valueOf(value: String): возвращает объект перечисления по названию константы
values(): возвращает массив констант текущего перечисления

Делегирование

Делегирование представляет паттерн объектно-ориентированного программирования, который позволяет одному объекту делегировать/перенаправить все запросы другому объекту. В определенной степени делегирование может выступать альтернативой наследованию. И преимуществом Kotlin в данном случае состоит в том, что Kotlin нативно поддерживает данный паттерн, предоставляя необходимый инструментарий.

Множественное делегирование
Подобным образом один объект может делегировать выполнение различных функций разным объектам. Например:

Делегирование свойств
По аналогии с функциями объект может делегировать обращение к свойствам:


Анонимные классы и объекты
Иногда возникает необходимость создать объект некоторого класса, который больше нигде в программе не используется. То есть класс необходим только для создания только одного объекта. В этом случае мы, конечно, можем, как и обычно, определить класс и затем создать объект этого класса. Но Kotlin для таких ситуаций предоставлять возможность определить объект анонимного класса.

Анонимные классы не используют ключевое слово class для определения. Они не имеют имени, но как и обычные классы могут наслдовать другие классы или применять интерфейсы. Объекты анонимных классов называют анонимыми объктами.

Наследование анонимных объектом
При наследовании после слова object через двоеточия указывается имя наследуемого класса или его первичный конструктор:

Анонимный объект как аргумент функции
Анонимный объект может передаваться в качестве аргумента в вызов функции:

Анонимный объект как результат функции
Функция может возвращать анонимный объект:


// STOP  Обобщения
Обобщенные классы и функции


Обобщения
Обобщенные классы и функции
Generics или обобщения представляют технику, посредством которой методы и классы могут использовать объекты, типы которых на момент определения классов и функций неизвестны. Обобщения позволяют определять шаблоны, в которые можно подставлять различные типы.
class Person<T>(val id: T, val name: String)

Ограничения обобщений
Ограничения обобщений (generic constraints) ограничивают набор типов, которые могут передаваться вместо параметра в обобщениях.

Стоит отметить, что по умолчанию ко всем параметрам типа также применяется ограничение в виде типа Any?. То есть определение параметра типа <T> фактически аналогично определению <T: Any?>

Классы, как и функции, могут принимать ограничения обощений.


Вариантность, ковариантность и контравариантность
Вариантность описывает, как обобщенные типы, типизированные классами из одной иерархии наследования, соотносятся друг с другом.

Ковариантость
Ковариантость предполагает, что, если у нас есть классы Base и Derived, где Base - базовый класс для Derived, то класс SomeClass<Base> является базовым классом для SomeClass<Derived>
Для определения обобщенного типа как ковариантного параметр обощения определяется с ключевым словом out:
-
Поскольку в Messenger параметр T определен с аннотацией out, то мы можем присвоить переменной типа Messenger<Message> значение типа EmailMessenger (а по сути значение типа Messenger<EmailMessage>)
-
В то же время тип T нельзя использовать в качестве типа входных параметров функции. Например, в следующем случае компилятор известит нас об ошибке:

Контравариантность
Применение аннотации in означает, что обобщенный тип может получать значение типа T через параметр функции:
-
В данном случае интерфейс Messenger является контравариантным, так как его параметр определен со словом in: interface Messenger<in T>. И теперь переменной типа Messenger<EmailMessage> мы можем присвоить значение типа Messenger<Message>
-
Применение аннотации in означает, что обобщенный тип может получать значение типа T через параметр функции:










