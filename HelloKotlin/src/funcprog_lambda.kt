fun main() {
    // Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию.
    val hello = {println("Hello Kotlin")}
    hello()
    hello()

    // Также лямбда-выражение можно выполнить сразу при определении с помощью оператора run:
    run {println("Hello Kotlin")};

    // Либо можно запускать как обычную функцию, используя круглые скобки:
    {println("Hello Kotlin")}();

    // Передача параметров
    //Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка ->.
    // Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.
    val printer = {message: String -> println(message)}
    printer("Hello")
    printer("Good Bye");

    // При вызове лямбда-выражения сразу при его определении в скобках передаются значения для его параметров:
    {message: String -> println(message)}("Welcome to Kotlin");

    val sum = {x:Int, y:Int -> println(x + y)}
    sum(2, 3)   // 5
    sum(4, 5)   // 9

    // Но также может возвращаться конкретное значение:
    val sum2 = {x:Int, y:Int -> x + y}
    val a2 = sum2(2, 3)   // 5
    val b2 = sum2(4, 5)   // 9
    println("a=$a2  b=$b2")

    // Лямбда-выражения как аргументы функций
    //Лямбда-выражения можно передавать параметрам функции, если они представляют один и тот же тип функции:
    doOperation2(3, 4, sum2)                          // 7
    doOperation2(3, 4, {a:Int, b: Int -> a * b}) // 12

    //Типизиция параметров лямбды
    //При передаче лямбды параметру или переменной, для которой явным образом указан тип, мы можем опустить в
    // лямбда-выражении типы параметров:
    val sum7: (Int, Int) -> Int = {x, y -> x + y }
    doOperation7(3, 4, {a, b -> a * b})

    // trailing lambda
    // Если параметр, который принимает функцию, является последним в списке, то при передачи ему лямбда-выражения,
// саму лямбду можно прописать после списка параметров. Например, возьмем выше использованную функцию doOperation():
    doOperation7(3, 4, {a, b -> a * b}) // 12

    // Мы также можем написать так:
    doOperation(3, 4) {a, b -> a * b} // 12


    //Возвращение лямбда-выражения из функции
    //Также фукция может возвращать лямбда-выражение, которое соответствует типу ее возвращаемого результата:
    val action1 = selectAction3(1)
    val result1 = action1(4, 5)
    println(result1)        // 9

    val action2 = selectAction3(3)
    val result2 = action2(4, 5)
    println(result2)        // 20

    val action3 = selectAction3(9)
    val result3 = action3(4, 5)
    println(result3)        // 0
}

fun doOperation2(x: Int, y: Int, op: (Int, Int) ->Int){

    val result = op(x, y)
    println(result)
}

fun doOperation7(x: Int, y: Int, op: (Int, Int) ->Int){

    val result = op(x, y)
    println(result)
}

fun selectAction3(key: Int): (Int, Int) -> Int{
    // определение возвращаемого результата
    when(key){
        1 -> return {x, y -> x + y }
        2 -> return {x, y -> x - y }
        3 -> return {x, y -> x * y }
        //else -> return {x, y -> 0 }
        //  оно не использует параметры, эти параметры не нужны. В этом случае вместо неиспользуемых параметров можно указать прочерки:
        else -> return {_, _ -> 0 }
    }
}